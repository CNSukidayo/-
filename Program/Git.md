# 目录:  

**附录:**  
A.Git常用技巧  




## 附录:  
A.Git常用技巧


### A.Git常用技巧
* 名词解释:
  * HEAD:当前版本的指针 
  * origin:远程分支(原始的) 
  * branch:分支 
  * remote:远程 
  * hash:版本的哈希码 
  * file:文件的相对路径 
  * addr:项目的远程地址 
  * stashversion:现场版本号(该值是通过git stash list得到的冒号前的内容,使用的时候一定要加双引号) 
  * vague:模糊 
  * tag:标签(github中的releases),给某一次提交打上一个标签,该标签就相当于一个版本可以被单独下载(就是GitHub中的项目的每个版本).
  * addrAS:特指通过git remote add origin [addr]命令用一个值指代远程项目地址
* 远程的origin相当于一个单独的分支(远程的分支名称就是origin/本地分支名,<font color="#00FF00">前提是已经关联</font>)通过这个分支感知远程仓库的内容(这个分支在本地也有一份,相当于<font color="#FFC800">本地的远程分支</font>),而本地的master又相当于一个单独的分支.
* 每一步操作都会被记录,但是该操作是否生效则不一定
* 一般每个开发者都有自已专属的分支  
  假设远程的公共的开发分支为dev,可以将该远程分支拉到本地;然后基于该分支开辟一个自已的分支,自已平常在该分支上修改,修改的代码commit之后合并到本地的dev分支,然后再将dev推送到远程分支.
* 合并分支并不是真正意义上的融合,只是说将otherBranch分支上所有版本库的操作再对被合并的分支执行一次.(首先AB分支版本相同,A分支删除了一些文件,此时将A分支合并到B分支,B分支就会删除这些文件)
* 合并分支产生冲突时,记住master分支不应该去处理冲突,而是应该让和master产生冲突的那条分支去处理冲突.冲突分支的那一方首先应该去合并master分支,然后冲突分支再去处理冲突,冲突解决完后再让master分支去合并刚刚冲突的分支.master要做的就是通过git reset命令回到合并之前的版本(原因是当master主动去与冲突分支合并时默认就会让master去处理这个冲突,但是不能让master去处理冲突所以要让master回滚到冲突之前的版本)有冲突是需要协商的.
* 当两个分支的版本相同时并且修改了同一行(合并的时候只会合并版本库),此时合并分支就会产生冲突.如果一个分支的版本领先另一个分支,那么当高版本分支想要合并到低版本分支时就算修改了同一行也不会产生冲突,低版本会直接来到高版本的最新版本.当两个分支产生冲突时,解决完后会进行两次提交,第一次提交相当于克隆目标分支的hash值,第二次提交是解决完冲突后的提交.!!!!!!另外冲突产生的原因还有不规范(比如git cherry-pick [hash]命令跨节点复制)、分支不是同一祖先.
* 远端分支的更改本地是感知不到的
* pull request和Fork,Fork完项目后我们在Fork的项目的dev分支中修改代码后在主页点击Compare&pull request,然后填入当前修改的提交信息 然后点击create pull request.然后仓库的拥有者就会审查你的代码进行合并操作.
* 如果想忽略某些文件,在.git同级目录下创建.gitignore,然后在该文件中填入你需要屏蔽的文件,另外文件的目录也是支持通配符的.
* 建议(规范):在功能没有开发完之前不要commit
* 规定(必须):在没有开发完毕之前(commit)不能checkout(切换分支)
* 在游离状态下,如果对过去的版本进行了修改并且提交了,那么过去版本的后面的版本是不会感知到这次修改的,只有通过新建分支然后合并来达到修改的目的.
* 保存现场的前提是要添加到暂存区中,**如果一个文件只存在于工作区那么这个文件是属于任何一个分支的**(不然怎么让你切换分支前要commit呢?)
* 还原现场的时候工作区必须是干净的,如果你不想要现在工作区的内容可以通过git restore [file]将工作区**回滚**到当前HEAD指向的版本.
* 如果先保存现场,然后修改了和保存现场同一行的内容,此时提交.然后再还原现场此时就会产生冲突.
* 标签和分支是没有关系的,标签不针对分支可以被任意分支看到.
* master分支一般很少改变,dev分支一般用来开发,test分支用来测试.master一般就是生产阶段了
* 当通过git checkout origin/master切换到远程分支时会处于一个游离状态.所以既然是处于游离状态,就不是真正意义上的切换分支,而是到达了远程分支的某个版本,即没有切换远程分支的说法,切换到远程分支就是进入游离状态.
* 如果项目是克隆下来的,则这个项目是不需要执行`git push -u origin [LocalBranch]`操作的.
* 假设A和B同时修改了同一行,A先commit并且push到远程.B再commit并且push到远程,由于修改了同一行必然产生冲突,所以B的这次push压根就不会成功,此时B就需要先pull,pull完了之后因为修改了同一行必然有冲突所以此时B就要去解决这个冲突,解决完后push(会有两次commit)
* 本地有的远程没有的分支,用`git push -u origin [branchName]`(或者`git push origin`) 在远程创建分支并和本地关联,远程有的本地没有的查看git checkout -b [branchName] [remoteBranch]\(不能直接使用\)或者看git pull [remoteBranch]:[localBranch]
* 对于一个有关联的分支,实际上是有3条分支.第一条就是本地的分支,第二条就是远程的分支,第三条是本地的远程分支(用该分支来感应远程分支)
* 标签的性质和文件是一样的,如果一个标签本地有远程没有,调用<font color="#00FF00">git pull之后本地有的标签是不会删除的</font>.所以有些时候文件和标签是可以类比的,实际上一个标签在.git目录里就有与之对应的文件.
* 当我们通过git submodule关联另外一个项目时,假设另外一个项目的内容发生改变并且push了,但是原项目是感知不到这次提交的,所以我们必须进入到原项目的依赖项目然后通过git pull更新依赖项目,但是这次pull只是将本地的依赖项目更新了,远程的依赖还没有更新,此时在原项目执行 git add->git commit->git push才能让远程更新.
* 没有命令直接解除当前项目的关联项目,首先执行git restore --staged [file]将依赖项目的文件夹从缓存区删除,然后删除依赖项目文件夹.->git add ->git commit ->git push
* 上面两条介绍的都是单向依赖,在这种依赖环境下原项目是不能直接修改依赖项目的远程内容的(当然本地的可以修改).而在互相依赖状态下当前项目修改完依赖项目后可以push到远程,远程就可以被改变.
